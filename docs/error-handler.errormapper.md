<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@khni/error-handler](./error-handler.md) &gt; [errorMapper](./error-handler.errormapper.md)

## errorMapper() function

Maps CustomError instances to appropriate HttpError instances using a provided mapping configuration. This function enables seamless conversion of business logic errors to HTTP errors with proper status codes and client-safe messages.

**Signature:**

```typescript
export declare function errorMapper<CodeType extends string | number | symbol>(error: CustomError<CodeType>, codeMapping: Record<CodeType, {
    statusCode: number;
    responseMessage: string;
}>): HttpError;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

error


</td><td>

[CustomError](./error-handler.customerror.md)<!-- -->&lt;CodeType&gt;


</td><td>

The CustomError instance to map


</td></tr>
<tr><td>

codeMapping


</td><td>

Record&lt;CodeType, { statusCode: number; responseMessage: string; }&gt;


</td><td>

Configuration object mapping error codes to HTTP responses


</td></tr>
</tbody></table>

**Returns:**

[HttpError](./error-handler.httperror.md)

An HttpError instance with appropriate status code and response message

## Remarks

The mapper provides a clean separation between business logic errors (CustomError) and presentation layer errors (HttpError). This allows: - Business logic to throw domain-specific errors without HTTP concerns - Consistent HTTP status code mapping across the application - Client-safe error messages that don't expose internal details - Fallback handling for unmapped error codes

## Example 1


```typescript
// Define error codes as const for type safety
const ErrorCodes = {
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  INVALID_EMAIL: 'INVALID_EMAIL',
  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
} as const;

type ErrorCode = keyof typeof ErrorCodes;

// Create mapping configuration
const errorMapping: Record<ErrorCode, { statusCode: number; responseMessage: string }> = {
  USER_NOT_FOUND: {
    statusCode: 404,
    responseMessage: 'User not found'
  },
  INVALID_EMAIL: {
    statusCode: 400,
    responseMessage: 'Please provide a valid email address'
  },
  INSUFFICIENT_PERMISSIONS: {
    statusCode: 403,
    responseMessage: 'You do not have permission to perform this action'
  }
};

// Usage in service layer
class UserService {
  async getUser(userId: string) {
    try {
      const user = await userRepository.findById(userId);
      if (!user) {
        throw new UserError({
          name: 'UserNotFoundError',
          message: `User with ID ${userId} not found`,
          code: 'USER_NOT_FOUND',
          logLevel: 'warn'
        });
      }
      return user;
    } catch (error) {
      if (error instanceof UserError) {
        // Map to HTTP error for controller layer
        throw errorMapper(error, errorMapping);
      }
      throw error;
    }
  }
}

// Usage in Express controller
app.get('/users/:id', async (req, res, next) => {
  try {
    const user = await userService.getUser(req.params.id);
    res.json(user);
  } catch (error) {
    next(error); // Will be handled by error middleware
  }
});
```

## Example 2


```typescript
// Advanced usage with fallback handling
const businessErrorMapping = {
  PRODUCT_OUT_OF_STOCK: { statusCode: 409, responseMessage: 'Product is out of stock' },
  PAYMENT_FAILED: { statusCode: 402, responseMessage: 'Payment processing failed' },
  // ... other mappings
};

try {
  await orderService.processOrder(orderData);
} catch (error) {
  if (error instanceof BusinessError) {
    const httpError = errorMapper(error, businessErrorMapping);

    // Log with original error context
    logger[httpError.logLevel](`Order processing failed: ${error.message}`, {
      originalError: error,
      mappedError: httpError
    });

    throw httpError;
  }
  throw error;
}
```

